<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="6091b617-d0de-42d2-a97e-b2107a0c8def" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_core_async_1_3_610.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_core_cache_1_0_207.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_core_memoize_1_0_236.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_data_priority_map_1_0_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_analyzer_1_0_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_analyzer_jvm_1_1_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_reader_1_3_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_ow2_asm_asm_5_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/async_study/http.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/async-study.iml" beforeDir="false" afterPath="$PROJECT_DIR$/async-study.iml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/project.clj" beforeDir="false" afterPath="$PROJECT_DIR$/project.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/async_study/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/async_study/core.clj" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DepsLocalSettings">
    <option name="repoId" value="" />
    <option name="repoUrl" value="" />
    <option name="projectSyncType">
      <map>
        <entry key="$PROJECT_DIR$/../../anki-clj/server" value="PREVIEW" />
      </map>
    </option>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="JavaFXApplication" />
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1j8isk7cvK4lp38USBnghb91tko" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="PropertiesComponent">
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="cursive.last.file.extension./home/evohc/Files/projects/async-clojure-clojurescript/async-study/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="AndroidSdkUpdater" />
    <property name="show.migrate.to.gradle.popup" value="false" />
  </component>
  <component name="ReplState" timestamp="1603327587120">{:repl-history {:ide [], :local [{:command &quot;(ns async-study.core\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!!]]))&quot;, :offset 77, :ns &quot;async-study.core&quot;} {:command &quot;(defn channels []\n  (let [c (chan)]\n    (future (&gt;!! c 42))\n    (future (println (&lt;!! c)))))&quot;, :offset 92, :ns &quot;async-study.core&quot;} {:command &quot;(defn channels []\n  (let [c (chan)]\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n    (future (println (&lt;!! c)))))&quot;, :offset 122, :ns &quot;async-study.core&quot;} {:command &quot;(defn channels []\n  (let [c (chan)]\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n    (future (dotimes [x 10]\n              (println (&lt;!! c))))))&quot;, :offset 153, :ns &quot;async-study.core&quot;} {:command &quot;(defn channels []\n  (let [c (chan)]\n    ;;puts values in chan (FIFO)\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n\n    ;;pop values from chan\n    (future (dotimes [x 10]\n              (println (&lt;!! c))))))&quot;, :offset 269, :ns &quot;async-study.core&quot;} {:command &quot;(defn channels []\n  (let [c (chan)]\n    ;;puts values in chan (FIFO)\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n\n    ;;pop values from chan\n    (future (dotimes [x 20]\n              (println (&lt;!! c))))))&quot;, :offset 269, :ns &quot;async-study.core&quot;} {:command &quot;(channels)&quot;, :offset 10, :ns &quot;async-study.core&quot;} {:command &quot;(ns async-study.core\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!]]))&quot;, :offset 88, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan)]\n  (put! c 42)\n  (take! c (fn [v] (println \&quot;Got: \&quot; v))))&quot;, :offset 71, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan)]\n  (put! c 42 (fn [v] (println \&quot;Sent: \&quot; v)))\n  (take! c (fn [v] (println \&quot;Got: \&quot; v))))&quot;, :offset 101, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 1)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x)))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))\n&quot;, :offset 156, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 1)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x)))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 155, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 1)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x)))\n  #_(future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 157, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 2)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x)))\n  #_(future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 157, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 2)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  #_(future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 178, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 3)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  #_(future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 178, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan 3)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 176, :ns &quot;async-study.core&quot;} {:command &quot;(ns async-study.core\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer]]))&quot;, :offset 199, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (dropping-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 2]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 194, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (dropping-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      #_(println \&quot;Sent : \&quot; x)\n      )\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 2]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 203, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (dropping-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      #_(println \&quot;Sent : \&quot; x)\n      )\n    #_(println \&quot;done\&quot;)\n    )\n  (future\n    (dotimes [x 2]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))&quot;, :offset 210, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (dropping-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      #_(println \&quot;Sent : \&quot; x)\n      )\n    #_(println \&quot;done\&quot;)\n    )\n  (future\n    (dotimes [x 2]\n      (println \&quot;Got:\&quot; (&lt;!! c)))\n    (println \&quot;done\&quot;)))&quot;, :offset 231, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (dropping-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      #_(println \&quot;Sent : \&quot; x)\n      )\n    #_(println \&quot;done\&quot;)\n    )\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))\n    (println \&quot;done getting\&quot;)))&quot;, :offset 239, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (sliding-buffer 3))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))\n    (println \&quot;done getting\&quot;)))&quot;, :offset 222, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan (sliding-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))\n    (println \&quot;done getting\&quot;)))&quot;, :offset 222, :ns &quot;async-study.core&quot;} {:command &quot;(ns async-study.core\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close]]))&quot;, :offset 245, :ns &quot;async-study.core&quot;} {:command &quot;(ns async-study.core\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close!]]))&quot;, :offset 246, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan)]\n  (future\n    (dotimes [x 2]\n      (&gt;!! c x))\n    (close! c)\n    (println \&quot;Closed.\&quot;))\n  (future\n    (loop []\n      (when-some [v (&lt;!! c)]\n        (println \&quot;Got: \&quot; v)\n        (recur)))\n    (println \&quot;Exiting\&quot;)))&quot;, :offset 225, :ns &quot;async-study.core&quot;} {:command &quot;(ns async-study.channels-study\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close!]]))&quot;, :offset 256, :ns &quot;async-study.core&quot;} {:command &quot;(defn channels []\n  ;;must comum way to create a channel simple FIFO (first in first out)\n  (let [c (chan)]\n    ;;puts values in chan (FIFO)\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n\n    (future (dotimes [x 10]\n              (&gt;!! c x)))\n\n    ;;pop values from chan\n    (future (dotimes [x 20]\n              (println (&lt;!! c))))))\n\n(channels)\n\n;;put value and take value from chan\n(let [c (chan)]\n  (put! c 42 (fn [v] (println \&quot;Sent: \&quot; v)))\n  (take! c (fn [v] (println \&quot;Got: \&quot; v))))\n\n;;chann with a buffer size 1\n;;\n(let [c (chan 3)]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))))\n\n\n\n(let [c (chan (dropping-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      #_(println \&quot;Sent : \&quot; x)\n      )\n    #_(println \&quot;done\&quot;)\n    )\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))\n    (println \&quot;done getting\&quot;)))\n\n\n\n(let [c (chan (sliding-buffer 2))]\n  (future\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Sent : \&quot; x))\n    (println \&quot;done\&quot;))\n  (future\n    (dotimes [x 3]\n      (println \&quot;Got:\&quot; (&lt;!! c)))\n    (println \&quot;done getting\&quot;)))\n\n\n;;;Close a channels\n(let [c (chan)]\n  (future\n    (dotimes [x 2]\n      (&gt;!! c x))\n    (close! c)\n    (println \&quot;Closed.\&quot;))\n  (future\n    (loop []\n      (when-some [v (&lt;!! c)]\n        (println \&quot;Got: \&quot; v)\n        (recur)))\n    (println \&quot;Exiting\&quot;)))&quot;, :offset 1420, :ns &quot;async-study.channels-study&quot;} {:command &quot;(ns async-study.thread\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close!\n                                        thread!]]))&quot;, :offset 296, :ns &quot;async-study.core&quot;} {:command &quot;(ns async-study.thread\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close!\n                                        thread]]))&quot;, :offset 295, :ns &quot;async-study.core&quot;} {:command &quot;(thread 42)&quot;, :offset 11, :ns &quot;async-study.thread&quot;} {:command &quot;(&lt;!! (thread 42))&quot;, :offset 17, :ns &quot;async-study.thread&quot;} {:command &quot;(&lt;!! (thread\n       (println \&quot;Inside thread\&quot;)\n       42))&quot;, :offset 57, :ns &quot;async-study.thread&quot;} {:command &quot;(&lt;!! (thread\n       (let [t1 (thread \&quot;Thread 1\&quot;)\n             t2 (thread \&quot;Thread 2\&quot;)]\n         [(&lt;!! t1)\n          (&lt;!! t2)])))&quot;, :offset 127, :ns &quot;async-study.thread&quot;} {:command &quot;(let [c (chan)]\n  (thread\n    (dotimes [x 3]\n      (&gt;!! c x)\n      (println \&quot;Put: \&quot; x)))\n  (thread\n    (dotimes [x 3]\n      (println \&quot;Take: \&quot; (&lt;!! c)))))&quot;, :offset 153, :ns &quot;async-study.thread&quot;} {:command &quot;(ns async-study.thread\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close!\n                                        thread\n                                        go]]))&quot;, :offset 338, :ns &quot;async-study.core&quot;} {:command &quot;(go 42)&quot;, :offset 7, :ns &quot;async-study.thread&quot;} {:command &quot;(ns async-study.thread\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! put! take!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        close!\n                                        thread\n                                        go\n                                        &gt;!\n                                        &lt;!]]))&quot;, :offset 424, :ns &quot;async-study.core&quot;} {:command &quot;(let [c (chan)]\n  (go (dotimes [x 3]\n        (&gt;! c x)\n        (println \&quot;Put: \&quot; x)))\n  (go (dotimes [x 3]\n        (println \&quot;Take: \&quot; (&lt;! c)))))&quot;, :offset 141, :ns &quot;async-study.thread&quot;} {:command &quot;(defn http-get [url]\n  (let [c (chan)]\n    (println url)\n    (htt/get url (partial put! c r))\n    c))\n\n(defn request-and-process [nm]\n  (go\n    (-&gt; (str \&quot;http://imdbapi.poromenos.org/js/?name=%25\&quot; nm \&quot;%25\&quot;)\n        http-get\n        &lt;!\n        :body\n        (cheshire/parse-string true))))&quot;, :offset 288, :ns &quot;async-study.http&quot;} {:command &quot;(ns async-study.http\n  (:require [org.httpkit.client :as http]\n            [clojure.core.async :refer [chan &lt;! &gt;! go put! &lt;!! &gt;!!]]\n            [cheshire.core :as cheshire]))\n&quot;, :offset 175, :ns &quot;async-study.core&quot;} {:command &quot;(defn http-get [url]\n  (let [c (chan)]\n    (println url)\n    (htt/get url (partial put! c r))\n    c))\n\n(defn request-and-process [nm]\n  (go\n    (-&gt; (str \&quot;http://imdbapi.poromenos.org/js/?name=%25\&quot; nm \&quot;%25\&quot;)\n        http-get\n        &lt;!\n        :body\n        (cheshire/parse-string true))))\n&quot;, :offset 289, :ns &quot;async-study.http&quot;} {:command &quot;(defn http-get [url]\n  (let [c (chan)]\n    (println url)\n    (http/get url (partial put! c r))\n    c))&quot;, :offset 102, :ns &quot;async-study.http&quot;} {:command &quot;(defn http-get [url]\n  (let [c (chan)]\n    (println url)\n    (http/get url (partial put! c ))\n    c))&quot;, :offset 101, :ns &quot;async-study.http&quot;} {:command &quot;(defn request-and-process [nm]\n  (go\n    (-&gt; (str \&quot;http://imdbapi.poromenos.org/js/?name=%25\&quot; nm \&quot;%25\&quot;)\n        http-get\n        &lt;!\n        :body\n        (cheshire/parse-string true))))&quot;, :offset 185, :ns &quot;async-study.http&quot;} {:command &quot;(defn request-and-process [nm]\n  (go\n    (-&gt; (str \&quot; https://www.imdb.com/title/tt12392504/?ref_=hm_fanfav_tt_2_pd_fp1\&quot;)\n        http-get\n        &lt;!\n        :body\n        (cheshire/parse-string true))))&quot;, :offset 201, :ns &quot;async-study.http&quot;} {:command &quot;(defn request-and-process [nm]\n  (go\n    (-&gt; (str \&quot;https://imdbapi.poromenos.org/js/?name=%25\&quot; nm \&quot;%25\&quot;)\n        http-get\n        &lt;!\n        :body\n        (cheshire/parse-string true))))&quot;, :offset 186, :ns &quot;async-study.http&quot;} {:command &quot;(&lt;!! (request-and-process \&quot;Matrix\&quot;))&quot;, :offset 36, :ns &quot;async-study.http&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager">
    <configuration name="Repl" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="async-study" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="6091b617-d0de-42d2-a97e-b2107a0c8def" name="Default Changelist" comment="" />
      <created>1603192327960</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1603192327960</updated>
    </task>
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>